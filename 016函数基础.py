# 函数基础
# 在Python中，采用下面的语法定义函数：
"""  
def 函数名(参数):
    # 内部代码
    return 表达式 

"""
def summer(lis):
    """
    这里是函数的说明文档，doc的位置
    :param lis: 参数列表的说明
    :return: 返回值的说明
    """
    total = 0
    for i in lis:
        total += i
    return total

sum = summer([1,2,3,4,5])
print(sum) #15

# 函数代码块以def关键词开头，一个空格之后接函数标识符名称和圆括号()，再接个冒号。
# 任何传入的参数必须放在圆括号中间。
# 函数的第一行语句后可以选择性地使用文档字符串—用于存放函数说明。
# 函数内容以冒号起始，并且缩进。
# 使用return结束函数。默认返回None。
# return语句依然在函数体内部，不能回退缩进。直到函数的所有代码写完，才回退缩进，表示函数体结束。

# 函数调用
"""  
调用的同时要根据函数的定义体，提供相应个数和类型的参数，每个参数之间用逗号分隔。
Python由于动态语言的特点，在做语法和词法分析检查的时候，并不会对参数类型进行检查，但在执行过程中，如果参数类型不符合函数内部运行机制的话，会弹出相应的错误
"""

# return语句：
"""  
return语句用于表示函数执行到此结束，并且返回return后面的对象。有时候，函数不需要返回任何值，此时可以不需要return语句，它在后台默认给你返回个None，并且不给任何提示。
但是更多的时候我们还是需要return一些东西。
一旦函数执行过程遇到return语句，那么之后函数体内的所有代码都会被忽略，直接跳出函数体。那怕你现在正在一个循环内。
"""

# return可以返回什么？
# 什么都不返回，仅仅return：return
# 数字/字符串/任意数据类型： return 'hello'
# 一个表达式：return 1+2
# 一个判断语句：return 100 > 99
# 一个变量：return a
# 一个函数调用：return func()
# 甚至是返回自己！：return self
# 多个返回值，以逗号分隔：return a, 1+2, "hello"

# 如何接收函数的返回值？
# result = func()
# 而对于同时返回多个值的函数，需要相应个数的变量来接收，变量之间以逗号分隔：
# a, b, c = func()

# 参数的传递
"""  
函数通常都有参数，用于将外部的实际数据传入函数内部进行处理。
但是，在处理不同数据类型的参数时，会有不同的情况发生。这一切都是因为以下两点。

    1、Python的函数参数传递的是实际对象的内存地址。
    2、Python的数据类型分可变数据类型和不可变数据类型。
"""

# 值传递里面修改不会影响外面
a = 1
def func(a):
    print("在函数内部修改之前,变量a的内存地址为： %s" % id(a))
    a = 2
    print("在函数内部修改之后,变量a的内存地址为： %s" % id(a))
    print("函数内部的a为： %s" % a)


print("调用函数之前,变量a的内存地址为： %s" % id(a))
func(a)
print("函数外部的a为：%s" % a)
"""  
a被传入函数时，将数字对象1的地址传递给了函数内部的a。执行第一句内部代码时，此时内部的a和外面的a其实是一个东西，因此打印出了同样的内存地址。
而当a=2被执行后，创建了一个新的内部变量a，并赋值2，将数字对象2的内存地址赋给变量a。
其次、函数由于存在作用域的概念（后面会介绍），在其内部的变量不受外部变量的影响
由于数字1和2是不可变的数字类型对象，是两个独立的，不同内存地址的对象，因此再次打印内存地址，当然就不一样了。
"""


# 引用传递  会改变外面的a1;
a1 = [1, 2, 3]
def func(b):
    print("在函数内部修改之前,变量b的内存地址为： %s" % id(b))
    b.append(4)
    print("在函数内部修改之后,变量b的内存地址为： %s" % id(b))
    print("函数内部的b为： %s" % b)


print("调用函数之前,变量a的内存地址为： %s" % id(a1))
func(a1)
print("函数外部的a为：%s" % a1)


